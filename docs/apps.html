<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>algoappdev.apps API documentation</title>
<meta name="description" content="Utilities for smart contract construction." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>algoappdev.apps</code></h1>
</header>
<section id="section-intro">
<p>Utilities for smart contract construction.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;Utilities for smart contract construction.&#34;&#34;&#34;

import base64
from typing import Dict, List, NamedTuple, Type, Union

import pyteal as tl
from algosdk.future.transaction import (
    ApplicationCreateTxn,
    ApplicationUpdateTxn,
    OnComplete,
    StateSchema,
    SuggestedParams,
)
from algosdk.v2client.algod import AlgodClient

from algoappdev.utils import AlgoAppDevError

Key = Union[int, str, bytes]
TealType = Union[Type[tl.Int], Type[tl.Bytes]]
TealValue = Union[tl.Int, tl.Bytes]

ZERO = tl.Int(0)
ONE = tl.Int(1)


def compile_expr(expr: tl.Expr) -&gt; str:
    &#34;&#34;&#34;
    Compile a teal expression to teal source code:

    Args:
        expr: the teal expression

    Returns:
        the teal source code
    &#34;&#34;&#34;
    return tl.compileTeal(
        expr,
        mode=tl.Mode.Application,
        version=tl.MAX_TEAL_VERSION,
    )


def compile_source(client: AlgodClient, source: str) -&gt; bytes:
    &#34;&#34;&#34;
    Compile teal source code into bytes.

    Args:
        client: the client connected to a node with the developer API
        source: the teal source code

    Returns:
        the teal program bytes
    &#34;&#34;&#34;
    result = client.compile(source)
    result = result[&#34;result&#34;]
    return base64.b64decode(result)


class State:
    &#34;&#34;&#34;Describes an app&#39;s state.&#34;&#34;&#34;

    class KeyInfo:
        &#34;&#34;&#34;
        Information about an app state key and associated value.
        &#34;&#34;&#34;

        def __init__(self, key: Key, type: TealType, default: tl.Expr = None):
            key = self.as_bytes(key)
            # the key as bytes
            self.key = key
            # the tl type of the key&#39;s value
            self.type = type
            # the tl expression to populate the initial value (can be None)
            self.default = default

        @staticmethod
        def as_bytes(key: Key) -&gt; bytes:
            &#34;&#34;&#34;
            Convert a key to it&#39;s byte representation. Validates that the key
            length doesn&#39;t surpass the Algorand maximum of 64 bytes.
            &#34;&#34;&#34;
            if isinstance(key, int):
                # At most 64 keys are allowed, so this fits in a byte. The
                # byte order is arbitrary as this is handled internally, but
                # use big-endian anyway to be consistent with TEAL conventions.
                key = key.to_bytes(1, &#34;big&#34;)
            if isinstance(key, str):
                return key.encode(&#34;utf8&#34;)
            elif isinstance(key, bytes):
                pass
            else:
                raise AlgoAppDevError(f&#34;invalid key type: {type(key)}&#34;)
            if len(key) &gt; 64:
                raise AlgoAppDevError(f&#34;key too long: {key}&#34;)
            return key

    def __init__(self, infos: List[KeyInfo]):
        self._key_to_info = {i.key: i for i in infos}
        self._maybe_values: Dict[bytes, tl.MaybeValue] = {}

    def key_info(self, key: Key):
        return self._key_to_info[State.KeyInfo.as_bytes(key)]

    def key_infos(self) -&gt; List[KeyInfo]:
        return list(self._key_to_info.values())

    def schema(self) -&gt; StateSchema:
        &#34;&#34;&#34;Build the schema for this state.&#34;&#34;&#34;
        num_uints = 0
        num_byte_slices = 0

        for info in self._key_to_info.values():
            if info.type is tl.Int:
                num_uints += 1
            elif info.type is tl.Bytes:
                num_byte_slices += 1

        return StateSchema(num_uints=num_uints, num_byte_slices=num_byte_slices)


class StateGlobalExternal(State):
    &#34;&#34;&#34;
    Read global state values which might or might not be present. This is the
    only way to interface with external apps, and can also be used to access
    values which might not yet be set in the current app.

    An object `MaybeValue` is itself a teal expression. It is also stateful,
    in that the expression, once constructed, stores the value into a slot,
    and that slot is cached in the `MaybeValue` object.

    For example:

    ```
    myabe = App.globalGetEx(app_id, key)
    Seq(maybe, maybe.value())
    ```

    In this snippet, the sequence first stores the values retreived by get,
    then the value is loaded onto the stack and can be used. To re-used the
    value from the given `key`, it is necessary to use the *same* `maybe`
    objet, as this one remembers which slot the value is stored in.

    Making a second `MaybeValue` object whith the same key will not re-use the
    stored values from the first object. The second object could also evaluated
    to store the same value into a *new* slot. But without this step, it&#39;s
    `load` method is oblivious to the slots used by the `globalGetEx` call.
    &#34;&#34;&#34;

    def __init__(self, keys: List[State.KeyInfo], app_id: tl.Expr):
        &#34;&#34;&#34;
        Build the read-only global state representation for app at `app_id`.

        Args:
            app_id: expression evaluating to the id of an app in the app array
        &#34;&#34;&#34;
        super().__init__(keys)
        self.app_id = app_id

    def get_ex(self, key: Key) -&gt; tl.MaybeValue:
        &#34;&#34;&#34;
        Get the `MaybeValue` object for `key`.

        The object itself is an expression to load the value into a slot. It
        also has members for accessing that value.

        After evaluating `MaybeValue`, then that object can be used to generate
        expression to access the value: `MaybeValue.value`. This means that a
        `MaybeValue` object must be cached if its value is to be accessed more
        than once, so it can remember which slot the value was stored in.
        &#34;&#34;&#34;
        info = self.key_info(key)
        maybe_value = self._maybe_values.get(info.key, None)
        if maybe_value is None:
            maybe_value = tl.App.globalGetEx(self.app_id, tl.Bytes(info.key))
            self._maybe_values[info.key] = maybe_value
        return maybe_value

    def load_ex_value(self, key: Key) -&gt; tl.Expr:
        &#34;&#34;&#34;
        Load a `MaybeValue` into a slot and return its value.

        If the key was previously loaded, the same scratch slot will be used.
        However, this will call `globalGetEx` and store its result anew, albeit
        in the same slot.

        The cost of repeating these operations can be avoided by pre-storing
        the value into a slot at the start of the program, and then accessing
        its `load` member subsequently.

        ```
        maybe = state.get_ex(key)
        expr = Seq(
            maybe,
            # ... some teal logic, with possible branches
            maybe.value()
            # ... some more teal logic
            maybe.value()
        )
        ```
        &#34;&#34;&#34;
        maybe_value = self.get_ex(key)
        return tl.Seq(maybe_value, maybe_value.value())

    def load_ex_has_value(self, key: Key) -&gt; tl.Expr:
        &#34;&#34;&#34;
        Load a `MaybeValue` into a slot and return if it has a value.

        See `load_ex_value` for notes on the `globalGetEx` calls.
        &#34;&#34;&#34;
        maybe_value = self.get_ex(key)
        return tl.Seq(maybe_value, maybe_value.hasValue())


class StateGlobal(StateGlobalExternal):
    def __init__(
        self,
        keys: List[State.KeyInfo],
    ):
        &#34;&#34;&#34;See `StateGlobalRead` but with write capability.&#34;&#34;&#34;
        # only state of the current application can be written
        super().__init__(keys, tl.Global.current_application_id())

    def get(self, key: Key) -&gt; tl.Expr:
        &#34;&#34;&#34;Build the expression to get the state value at `key`&#34;&#34;&#34;
        info = self.key_info(key)
        return tl.App.globalGet(tl.Bytes(info.key))

    def set(self, key: Key, value: TealValue) -&gt; tl.Expr:
        &#34;&#34;&#34;Build the expression to set the state value at `key`&#34;&#34;&#34;
        info = self.key_info(key)
        return tl.App.globalPut(tl.Bytes(info.key), value)

    def constructor(self) -&gt; tl.Expr:
        &#34;&#34;&#34;
        Build the expression to set the initial state values for those keys
        with an `default` member.
        &#34;&#34;&#34;
        return tl.Seq(
            *[
                tl.App.globalPut(tl.Bytes(i.key), i.default)
                for i in self.key_infos()
                if i.default
            ]
        )


class StateLocalExternal(State):
    &#34;&#34;&#34;See `StateGlobalExternal`, but for the local state.&#34;&#34;&#34;

    def __init__(self, keys: List[State.KeyInfo], app_id: tl.Expr, account: tl.Expr):
        &#34;&#34;&#34;
        Build the read-only local state representation for app at `app_id` in
        `account`.

        Args:
            app_id: expression evaluating to the id of an app in the app array
            account: expression evaluating to the account whose state is to be
                accessed
        &#34;&#34;&#34;
        super().__init__(keys)
        self.app_id = app_id
        self.account = account

    def get_ex(self, key: Key) -&gt; tl.MaybeValue:
        &#34;&#34;&#34;
        Get the `MaybeValue` object for `key`.

        See `StateGlobalExternal.get_ex`.
        &#34;&#34;&#34;
        info = self.key_info(key)
        maybe_value = self._maybe_values.get(info.key, None)
        if maybe_value is None:
            maybe_value = tl.App.localGetEx(
                self.account, self.app_id, tl.Bytes(info.key)
            )
            self._maybe_values[info.key] = maybe_value
        return maybe_value

    def load_ex_value(self, key: Key) -&gt; tl.Expr:
        &#34;&#34;&#34;
        Load a `MaybeValue` into a slot and return its value.

        See `StateGlobalExternal.load_ex_value`.
        &#34;&#34;&#34;
        maybe_value = self.get_ex(key)
        return tl.Seq(maybe_value, maybe_value.value())

    def load_ex_has_value(self, key: Key) -&gt; tl.Expr:
        &#34;&#34;&#34;
        Load a `MaybeValue` into a slot and return if it has a value.

        See `StateGlobalExternal.load_ex_has_value`.
        &#34;&#34;&#34;
        maybe_value = self.get_ex(key)
        return tl.Seq(maybe_value, maybe_value.hasValue())


class StateLocal(StateLocalExternal):
    def __init__(
        self,
        keys: List[State.KeyInfo],
    ):
        &#34;&#34;&#34;
        Build the local state representation for app at `app_id` in `account`.

        Args:
            app_id: expression evaluating to the id of an app in the app array
            account: expression evaluating to the account whose state is to be
                accessed
        &#34;&#34;&#34;
        # only state of the current application for the sender can be written
        super().__init__(keys, tl.Global.current_application_id(), tl.Txn.sender())

    def get(self, key: Key) -&gt; tl.Expr:
        &#34;&#34;&#34;Build the expression to get the state value at `key`&#34;&#34;&#34;
        info = self.key_info(key)
        return tl.App.localGet(self.account, tl.Bytes(info.key))

    def set(self, key: Key, value: TealValue) -&gt; tl.Expr:
        &#34;&#34;&#34;Build the expression to set the state value at `key`&#34;&#34;&#34;
        info = self.key_info(key)
        return tl.App.localPut(self.account, tl.Bytes(info.key), value)

    def constructor(self) -&gt; tl.Expr:
        &#34;&#34;&#34;
        Build the expression to set the initial state values for those keys
        with an `default` member.
        &#34;&#34;&#34;
        return tl.Seq(
            *[
                tl.App.localPut(self.account, tl.Bytes(i.key), i.default)
                for i in self.key_infos()
                if i.default
            ]
        )


class AppBuilder(NamedTuple):
    &#34;&#34;&#34;
    Build the program data required for an app to execute the provided
    expressions, with the provided app state.

    The app is specified as individual branches. At most one of those branches
    will execute when the application is called.

    Branches that can execute for an `ApplicationCall` transaction:

    - `on_create`: this expression is run when the app is first created only,
      and if it returns zero, the app cannot be created.
    - `on_delete`: this expression is run when a `DeleteApplication`
      transaction is sent, and if it returns zero the app cannot be deleted.
    - `on_update`: this expression is run when a `UpdateApplication`
      transaction is sent, and if it returns zero the app cannot be updated.
    - `on_opt_in`: this expression is run when a `OptIn` transaction is sent,
      and if it returns zero the app cannot be opted-in by accounts.
    - `on_close_out`: this expression is run when a `CloseOut` transaction is
      sent, and if it returns zero the app cannot be closed out by accounts.
    - `invocations[name]`: these expressions are run when a `NoOp` transaction
      is sent, and the first argument passed to the call is the bytes encoding
      of `name`.
    - `on_no_op`: this expression is run when a `NoOp` transaction is sent, and
      no invocation matches the first call argument (if supplied). This is the
      &#34;default invocation&#34;.

    Branch that executes for a `ClearState` transaction:

    - `on_clear`: this expression is run regardless of return value, but any
      state changes made in the expression are not committed if the return
      value is zero.

    The default app implements the following functionality:

    - creation is allowed and sets the global state defaults
    - deletion is not allowed
    - updating is not allowed
    - opt in is allowed and sets the local state defaults
    - close out is not allowed
    - clear is allowed
    - no invocations
    - no default invocation
    &#34;&#34;&#34;

    on_create: tl.Expr = None
    on_delete: tl.Expr = None
    on_update: tl.Expr = None
    on_opt_in: tl.Expr = None
    on_close_out: tl.Expr = None
    on_clear: tl.Expr = None
    invocations: Dict[str, tl.Expr] = None
    on_no_op: tl.Expr = None
    global_state: StateGlobal = None
    local_state: StateLocal = None

    def approval_expr(self) -&gt; tl.Expr:
        &#34;&#34;&#34;
        Assemble the provided expressions into the approval expression, by
        joining them in a single branching control flow.
        &#34;&#34;&#34;
        # Each branch is a pair of expressions: one which tests if the branch
        # should be executed, and another which is the branche&#39;s logic. If the
        # branch logic returns 0, then the app state is unchanged, no matter what
        # operations were performed during its exectuion (i.e. it rolls back). Only
        # the first matched branch is executed.
        branches = []

        on_create = self.on_create
        if not on_create:
            if self.global_state is not None:
                on_create = tl.Seq(self.global_state.constructor(), tl.Return(ONE))
            else:
                on_create = tl.Return(ONE)
        branches.append([tl.Txn.application_id() == ZERO, on_create])

        if self.on_delete:
            branches.append(
                [
                    tl.Txn.on_completion() == tl.OnComplete.DeleteApplication,
                    self.on_delete,
                ]
            )

        if self.on_update:
            branches.append(
                [
                    tl.Txn.on_completion() == tl.OnComplete.UpdateApplication,
                    self.on_update,
                ]
            )

        on_opt_in = self.on_opt_in
        if not on_opt_in:
            if self.local_state is not None:
                on_opt_in = tl.Seq(self.local_state.constructor(), tl.Return(ONE))
            else:
                on_opt_in = tl.Return(ONE)
        branches.append([tl.Txn.on_completion() == tl.OnComplete.OptIn, on_opt_in])

        if self.on_close_out:
            branches.append(
                [tl.Txn.on_completion() == tl.OnComplete.CloseOut, self.on_close_out]
            )

        # handle custon invocations with named arg
        invocations = {} if self.invocations is None else self.invocations
        for name, expr in invocations.items():
            branches.append(
                [
                    # use a an invocation branch for no-op calls with the branch
                    # name as arg 0
                    tl.And(
                        tl.Txn.on_completion() == tl.OnComplete.NoOp,
                        tl.If(tl.Txn.application_args.length() &gt;= ONE)
                        # if there is an argument passed, then it must match
                        # the invocation name
                        .Then(tl.Txn.application_args[0] == tl.Bytes(name))
                        # otherwise fail the branch
                        .Else(ZERO),
                    ),
                    expr,
                ]
            )

        # if no invocation matched, then try the default no-op
        if self.on_no_op:
            branches.append(
                [tl.Txn.on_completion() == tl.OnComplete.NoOp, self.on_no_op]
            )

        # fallthrough: if no branch is selected, reject
        branches.append([ONE, tl.Return(ZERO)])

        return tl.Cond(*branches)

    def clear_exrp(self) -&gt; tl.Expr:
        return self.on_clear if self.on_clear is not None else tl.Return(ONE)

    def global_schema(self) -&gt; StateSchema:
        return (
            self.global_state.schema()
            if self.global_state is not None
            else StateSchema()
        )

    def local_schema(self) -&gt; StateSchema:
        return (
            self.local_state.schema() if self.local_state is not None else StateSchema()
        )

    def create_txn(
        self, client: AlgodClient, address: str, params: SuggestedParams
    ) -&gt; ApplicationCreateTxn:
        &#34;&#34;&#34;
        Build the transaction to create the app.

        Args:
            client: the client connected to a node with the developer API, used
                for compiling and to send the transaction
            address: the address of the app creator sending the transaction
            params: the transaction parameters
        &#34;&#34;&#34;
        # create empty schemas if none are provided
        return ApplicationCreateTxn(
            # this will be the app creator
            sender=address,
            sp=params,
            # no state change requested in this transaciton beyond app creation
            on_complete=OnComplete.NoOpOC.real,
            # the program to handle app state changes
            approval_program=compile_source(client, compile_expr(self.approval_expr())),
            # the program to run when an account forces an opt-out
            clear_program=compile_source(client, compile_expr(self.clear_exrp())),
            # the amount of storage used by the app
            global_schema=self.global_schema(),
            local_schema=self.local_schema(),
        )

    def update_txn(
        self,
        client: AlgodClient,
        address: str,
        params: SuggestedParams,
        app_id: int,
    ) -&gt; ApplicationUpdateTxn:
        &#34;&#34;&#34;
        Build the transaction to update an app with this data.

        NOTE: the schema cannot be changed in an update transaction, meaning
        the state must be the same as that already used in `app_id`.

        Args:
            client: the client connected to a node with the developer API, used
                for compiling and to send the transaction
            address: the address of the app creator sending the transaction
            params: the transaction parameters
            app_id: the id of the exisiting application to update
        &#34;&#34;&#34;
        # ensure a valid clear program, interpret None as return zero
        return ApplicationUpdateTxn(
            sender=address,
            sp=params,
            index=app_id,
            approval_program=compile_source(client, compile_expr(self.approval_expr())),
            clear_program=compile_source(client, compile_expr(self.clear_exrp())),
        )</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="algoappdev.apps.compile_expr"><code class="name flex">
<span>def <span class="ident">compile_expr</span></span>(<span>expr: pyteal.Expr) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Compile a teal expression to teal source code:</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>expr</code></strong></dt>
<dd>the teal expression</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>the teal source code</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def compile_expr(expr: tl.Expr) -&gt; str:
    &#34;&#34;&#34;
    Compile a teal expression to teal source code:

    Args:
        expr: the teal expression

    Returns:
        the teal source code
    &#34;&#34;&#34;
    return tl.compileTeal(
        expr,
        mode=tl.Mode.Application,
        version=tl.MAX_TEAL_VERSION,
    )</code></pre>
</details>
</dd>
<dt id="algoappdev.apps.compile_source"><code class="name flex">
<span>def <span class="ident">compile_source</span></span>(<span>client: algosdk.v2client.algod.AlgodClient, source: str) ‑> bytes</span>
</code></dt>
<dd>
<div class="desc"><p>Compile teal source code into bytes.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>client</code></strong></dt>
<dd>the client connected to a node with the developer API</dd>
<dt><strong><code>source</code></strong></dt>
<dd>the teal source code</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>the teal program bytes</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def compile_source(client: AlgodClient, source: str) -&gt; bytes:
    &#34;&#34;&#34;
    Compile teal source code into bytes.

    Args:
        client: the client connected to a node with the developer API
        source: the teal source code

    Returns:
        the teal program bytes
    &#34;&#34;&#34;
    result = client.compile(source)
    result = result[&#34;result&#34;]
    return base64.b64decode(result)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="algoappdev.apps.AppBuilder"><code class="flex name class">
<span>class <span class="ident">AppBuilder</span></span>
<span>(</span><span>on_create: pyteal.Expr = None, on_delete: pyteal.Expr = None, on_update: pyteal.Expr = None, on_opt_in: pyteal.Expr = None, on_close_out: pyteal.Expr = None, on_clear: pyteal.Expr = None, invocations: Dict[str, pyteal.Expr] = None, on_no_op: pyteal.Expr = None, global_state: <a title="algoappdev.apps.StateGlobal" href="#algoappdev.apps.StateGlobal">StateGlobal</a> = None, local_state: <a title="algoappdev.apps.StateLocal" href="#algoappdev.apps.StateLocal">StateLocal</a> = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Build the program data required for an app to execute the provided
expressions, with the provided app state.</p>
<p>The app is specified as individual branches. At most one of those branches
will execute when the application is called.</p>
<p>Branches that can execute for an <code>ApplicationCall</code> transaction:</p>
<ul>
<li><code>on_create</code>: this expression is run when the app is first created only,
and if it returns zero, the app cannot be created.</li>
<li><code>on_delete</code>: this expression is run when a <code>DeleteApplication</code>
transaction is sent, and if it returns zero the app cannot be deleted.</li>
<li><code>on_update</code>: this expression is run when a <code>UpdateApplication</code>
transaction is sent, and if it returns zero the app cannot be updated.</li>
<li><code>on_opt_in</code>: this expression is run when a <code>OptIn</code> transaction is sent,
and if it returns zero the app cannot be opted-in by accounts.</li>
<li><code>on_close_out</code>: this expression is run when a <code>CloseOut</code> transaction is
sent, and if it returns zero the app cannot be closed out by accounts.</li>
<li><code>invocations[name]</code>: these expressions are run when a <code>NoOp</code> transaction
is sent, and the first argument passed to the call is the bytes encoding
of <code>name</code>.</li>
<li><code>on_no_op</code>: this expression is run when a <code>NoOp</code> transaction is sent, and
no invocation matches the first call argument (if supplied). This is the
"default invocation".</li>
</ul>
<p>Branch that executes for a <code>ClearState</code> transaction:</p>
<ul>
<li><code>on_clear</code>: this expression is run regardless of return value, but any
state changes made in the expression are not committed if the return
value is zero.</li>
</ul>
<p>The default app implements the following functionality:</p>
<ul>
<li>creation is allowed and sets the global state defaults</li>
<li>deletion is not allowed</li>
<li>updating is not allowed</li>
<li>opt in is allowed and sets the local state defaults</li>
<li>close out is not allowed</li>
<li>clear is allowed</li>
<li>no invocations</li>
<li>no default invocation</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AppBuilder(NamedTuple):
    &#34;&#34;&#34;
    Build the program data required for an app to execute the provided
    expressions, with the provided app state.

    The app is specified as individual branches. At most one of those branches
    will execute when the application is called.

    Branches that can execute for an `ApplicationCall` transaction:

    - `on_create`: this expression is run when the app is first created only,
      and if it returns zero, the app cannot be created.
    - `on_delete`: this expression is run when a `DeleteApplication`
      transaction is sent, and if it returns zero the app cannot be deleted.
    - `on_update`: this expression is run when a `UpdateApplication`
      transaction is sent, and if it returns zero the app cannot be updated.
    - `on_opt_in`: this expression is run when a `OptIn` transaction is sent,
      and if it returns zero the app cannot be opted-in by accounts.
    - `on_close_out`: this expression is run when a `CloseOut` transaction is
      sent, and if it returns zero the app cannot be closed out by accounts.
    - `invocations[name]`: these expressions are run when a `NoOp` transaction
      is sent, and the first argument passed to the call is the bytes encoding
      of `name`.
    - `on_no_op`: this expression is run when a `NoOp` transaction is sent, and
      no invocation matches the first call argument (if supplied). This is the
      &#34;default invocation&#34;.

    Branch that executes for a `ClearState` transaction:

    - `on_clear`: this expression is run regardless of return value, but any
      state changes made in the expression are not committed if the return
      value is zero.

    The default app implements the following functionality:

    - creation is allowed and sets the global state defaults
    - deletion is not allowed
    - updating is not allowed
    - opt in is allowed and sets the local state defaults
    - close out is not allowed
    - clear is allowed
    - no invocations
    - no default invocation
    &#34;&#34;&#34;

    on_create: tl.Expr = None
    on_delete: tl.Expr = None
    on_update: tl.Expr = None
    on_opt_in: tl.Expr = None
    on_close_out: tl.Expr = None
    on_clear: tl.Expr = None
    invocations: Dict[str, tl.Expr] = None
    on_no_op: tl.Expr = None
    global_state: StateGlobal = None
    local_state: StateLocal = None

    def approval_expr(self) -&gt; tl.Expr:
        &#34;&#34;&#34;
        Assemble the provided expressions into the approval expression, by
        joining them in a single branching control flow.
        &#34;&#34;&#34;
        # Each branch is a pair of expressions: one which tests if the branch
        # should be executed, and another which is the branche&#39;s logic. If the
        # branch logic returns 0, then the app state is unchanged, no matter what
        # operations were performed during its exectuion (i.e. it rolls back). Only
        # the first matched branch is executed.
        branches = []

        on_create = self.on_create
        if not on_create:
            if self.global_state is not None:
                on_create = tl.Seq(self.global_state.constructor(), tl.Return(ONE))
            else:
                on_create = tl.Return(ONE)
        branches.append([tl.Txn.application_id() == ZERO, on_create])

        if self.on_delete:
            branches.append(
                [
                    tl.Txn.on_completion() == tl.OnComplete.DeleteApplication,
                    self.on_delete,
                ]
            )

        if self.on_update:
            branches.append(
                [
                    tl.Txn.on_completion() == tl.OnComplete.UpdateApplication,
                    self.on_update,
                ]
            )

        on_opt_in = self.on_opt_in
        if not on_opt_in:
            if self.local_state is not None:
                on_opt_in = tl.Seq(self.local_state.constructor(), tl.Return(ONE))
            else:
                on_opt_in = tl.Return(ONE)
        branches.append([tl.Txn.on_completion() == tl.OnComplete.OptIn, on_opt_in])

        if self.on_close_out:
            branches.append(
                [tl.Txn.on_completion() == tl.OnComplete.CloseOut, self.on_close_out]
            )

        # handle custon invocations with named arg
        invocations = {} if self.invocations is None else self.invocations
        for name, expr in invocations.items():
            branches.append(
                [
                    # use a an invocation branch for no-op calls with the branch
                    # name as arg 0
                    tl.And(
                        tl.Txn.on_completion() == tl.OnComplete.NoOp,
                        tl.If(tl.Txn.application_args.length() &gt;= ONE)
                        # if there is an argument passed, then it must match
                        # the invocation name
                        .Then(tl.Txn.application_args[0] == tl.Bytes(name))
                        # otherwise fail the branch
                        .Else(ZERO),
                    ),
                    expr,
                ]
            )

        # if no invocation matched, then try the default no-op
        if self.on_no_op:
            branches.append(
                [tl.Txn.on_completion() == tl.OnComplete.NoOp, self.on_no_op]
            )

        # fallthrough: if no branch is selected, reject
        branches.append([ONE, tl.Return(ZERO)])

        return tl.Cond(*branches)

    def clear_exrp(self) -&gt; tl.Expr:
        return self.on_clear if self.on_clear is not None else tl.Return(ONE)

    def global_schema(self) -&gt; StateSchema:
        return (
            self.global_state.schema()
            if self.global_state is not None
            else StateSchema()
        )

    def local_schema(self) -&gt; StateSchema:
        return (
            self.local_state.schema() if self.local_state is not None else StateSchema()
        )

    def create_txn(
        self, client: AlgodClient, address: str, params: SuggestedParams
    ) -&gt; ApplicationCreateTxn:
        &#34;&#34;&#34;
        Build the transaction to create the app.

        Args:
            client: the client connected to a node with the developer API, used
                for compiling and to send the transaction
            address: the address of the app creator sending the transaction
            params: the transaction parameters
        &#34;&#34;&#34;
        # create empty schemas if none are provided
        return ApplicationCreateTxn(
            # this will be the app creator
            sender=address,
            sp=params,
            # no state change requested in this transaciton beyond app creation
            on_complete=OnComplete.NoOpOC.real,
            # the program to handle app state changes
            approval_program=compile_source(client, compile_expr(self.approval_expr())),
            # the program to run when an account forces an opt-out
            clear_program=compile_source(client, compile_expr(self.clear_exrp())),
            # the amount of storage used by the app
            global_schema=self.global_schema(),
            local_schema=self.local_schema(),
        )

    def update_txn(
        self,
        client: AlgodClient,
        address: str,
        params: SuggestedParams,
        app_id: int,
    ) -&gt; ApplicationUpdateTxn:
        &#34;&#34;&#34;
        Build the transaction to update an app with this data.

        NOTE: the schema cannot be changed in an update transaction, meaning
        the state must be the same as that already used in `app_id`.

        Args:
            client: the client connected to a node with the developer API, used
                for compiling and to send the transaction
            address: the address of the app creator sending the transaction
            params: the transaction parameters
            app_id: the id of the exisiting application to update
        &#34;&#34;&#34;
        # ensure a valid clear program, interpret None as return zero
        return ApplicationUpdateTxn(
            sender=address,
            sp=params,
            index=app_id,
            approval_program=compile_source(client, compile_expr(self.approval_expr())),
            clear_program=compile_source(client, compile_expr(self.clear_exrp())),
        )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.tuple</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="algoappdev.apps.AppBuilder.global_state"><code class="name">var <span class="ident">global_state</span> : <a title="algoappdev.apps.StateGlobal" href="#algoappdev.apps.StateGlobal">StateGlobal</a></code></dt>
<dd>
<div class="desc"><p>Alias for field number 8</p></div>
</dd>
<dt id="algoappdev.apps.AppBuilder.invocations"><code class="name">var <span class="ident">invocations</span> : Dict[str, pyteal.Expr]</code></dt>
<dd>
<div class="desc"><p>Alias for field number 6</p></div>
</dd>
<dt id="algoappdev.apps.AppBuilder.local_state"><code class="name">var <span class="ident">local_state</span> : <a title="algoappdev.apps.StateLocal" href="#algoappdev.apps.StateLocal">StateLocal</a></code></dt>
<dd>
<div class="desc"><p>Alias for field number 9</p></div>
</dd>
<dt id="algoappdev.apps.AppBuilder.on_clear"><code class="name">var <span class="ident">on_clear</span> : pyteal.Expr</code></dt>
<dd>
<div class="desc"><p>Alias for field number 5</p></div>
</dd>
<dt id="algoappdev.apps.AppBuilder.on_close_out"><code class="name">var <span class="ident">on_close_out</span> : pyteal.Expr</code></dt>
<dd>
<div class="desc"><p>Alias for field number 4</p></div>
</dd>
<dt id="algoappdev.apps.AppBuilder.on_create"><code class="name">var <span class="ident">on_create</span> : pyteal.Expr</code></dt>
<dd>
<div class="desc"><p>Alias for field number 0</p></div>
</dd>
<dt id="algoappdev.apps.AppBuilder.on_delete"><code class="name">var <span class="ident">on_delete</span> : pyteal.Expr</code></dt>
<dd>
<div class="desc"><p>Alias for field number 1</p></div>
</dd>
<dt id="algoappdev.apps.AppBuilder.on_no_op"><code class="name">var <span class="ident">on_no_op</span> : pyteal.Expr</code></dt>
<dd>
<div class="desc"><p>Alias for field number 7</p></div>
</dd>
<dt id="algoappdev.apps.AppBuilder.on_opt_in"><code class="name">var <span class="ident">on_opt_in</span> : pyteal.Expr</code></dt>
<dd>
<div class="desc"><p>Alias for field number 3</p></div>
</dd>
<dt id="algoappdev.apps.AppBuilder.on_update"><code class="name">var <span class="ident">on_update</span> : pyteal.Expr</code></dt>
<dd>
<div class="desc"><p>Alias for field number 2</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="algoappdev.apps.AppBuilder.approval_expr"><code class="name flex">
<span>def <span class="ident">approval_expr</span></span>(<span>self) ‑> pyteal.Expr</span>
</code></dt>
<dd>
<div class="desc"><p>Assemble the provided expressions into the approval expression, by
joining them in a single branching control flow.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def approval_expr(self) -&gt; tl.Expr:
    &#34;&#34;&#34;
    Assemble the provided expressions into the approval expression, by
    joining them in a single branching control flow.
    &#34;&#34;&#34;
    # Each branch is a pair of expressions: one which tests if the branch
    # should be executed, and another which is the branche&#39;s logic. If the
    # branch logic returns 0, then the app state is unchanged, no matter what
    # operations were performed during its exectuion (i.e. it rolls back). Only
    # the first matched branch is executed.
    branches = []

    on_create = self.on_create
    if not on_create:
        if self.global_state is not None:
            on_create = tl.Seq(self.global_state.constructor(), tl.Return(ONE))
        else:
            on_create = tl.Return(ONE)
    branches.append([tl.Txn.application_id() == ZERO, on_create])

    if self.on_delete:
        branches.append(
            [
                tl.Txn.on_completion() == tl.OnComplete.DeleteApplication,
                self.on_delete,
            ]
        )

    if self.on_update:
        branches.append(
            [
                tl.Txn.on_completion() == tl.OnComplete.UpdateApplication,
                self.on_update,
            ]
        )

    on_opt_in = self.on_opt_in
    if not on_opt_in:
        if self.local_state is not None:
            on_opt_in = tl.Seq(self.local_state.constructor(), tl.Return(ONE))
        else:
            on_opt_in = tl.Return(ONE)
    branches.append([tl.Txn.on_completion() == tl.OnComplete.OptIn, on_opt_in])

    if self.on_close_out:
        branches.append(
            [tl.Txn.on_completion() == tl.OnComplete.CloseOut, self.on_close_out]
        )

    # handle custon invocations with named arg
    invocations = {} if self.invocations is None else self.invocations
    for name, expr in invocations.items():
        branches.append(
            [
                # use a an invocation branch for no-op calls with the branch
                # name as arg 0
                tl.And(
                    tl.Txn.on_completion() == tl.OnComplete.NoOp,
                    tl.If(tl.Txn.application_args.length() &gt;= ONE)
                    # if there is an argument passed, then it must match
                    # the invocation name
                    .Then(tl.Txn.application_args[0] == tl.Bytes(name))
                    # otherwise fail the branch
                    .Else(ZERO),
                ),
                expr,
            ]
        )

    # if no invocation matched, then try the default no-op
    if self.on_no_op:
        branches.append(
            [tl.Txn.on_completion() == tl.OnComplete.NoOp, self.on_no_op]
        )

    # fallthrough: if no branch is selected, reject
    branches.append([ONE, tl.Return(ZERO)])

    return tl.Cond(*branches)</code></pre>
</details>
</dd>
<dt id="algoappdev.apps.AppBuilder.clear_exrp"><code class="name flex">
<span>def <span class="ident">clear_exrp</span></span>(<span>self) ‑> pyteal.Expr</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear_exrp(self) -&gt; tl.Expr:
    return self.on_clear if self.on_clear is not None else tl.Return(ONE)</code></pre>
</details>
</dd>
<dt id="algoappdev.apps.AppBuilder.create_txn"><code class="name flex">
<span>def <span class="ident">create_txn</span></span>(<span>self, client: algosdk.v2client.algod.AlgodClient, address: str, params: algosdk.future.transaction.SuggestedParams) ‑> algosdk.future.transaction.ApplicationCreateTxn</span>
</code></dt>
<dd>
<div class="desc"><p>Build the transaction to create the app.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>client</code></strong></dt>
<dd>the client connected to a node with the developer API, used
for compiling and to send the transaction</dd>
<dt><strong><code>address</code></strong></dt>
<dd>the address of the app creator sending the transaction</dd>
<dt><strong><code>params</code></strong></dt>
<dd>the transaction parameters</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_txn(
    self, client: AlgodClient, address: str, params: SuggestedParams
) -&gt; ApplicationCreateTxn:
    &#34;&#34;&#34;
    Build the transaction to create the app.

    Args:
        client: the client connected to a node with the developer API, used
            for compiling and to send the transaction
        address: the address of the app creator sending the transaction
        params: the transaction parameters
    &#34;&#34;&#34;
    # create empty schemas if none are provided
    return ApplicationCreateTxn(
        # this will be the app creator
        sender=address,
        sp=params,
        # no state change requested in this transaciton beyond app creation
        on_complete=OnComplete.NoOpOC.real,
        # the program to handle app state changes
        approval_program=compile_source(client, compile_expr(self.approval_expr())),
        # the program to run when an account forces an opt-out
        clear_program=compile_source(client, compile_expr(self.clear_exrp())),
        # the amount of storage used by the app
        global_schema=self.global_schema(),
        local_schema=self.local_schema(),
    )</code></pre>
</details>
</dd>
<dt id="algoappdev.apps.AppBuilder.global_schema"><code class="name flex">
<span>def <span class="ident">global_schema</span></span>(<span>self) ‑> algosdk.future.transaction.StateSchema</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def global_schema(self) -&gt; StateSchema:
    return (
        self.global_state.schema()
        if self.global_state is not None
        else StateSchema()
    )</code></pre>
</details>
</dd>
<dt id="algoappdev.apps.AppBuilder.local_schema"><code class="name flex">
<span>def <span class="ident">local_schema</span></span>(<span>self) ‑> algosdk.future.transaction.StateSchema</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def local_schema(self) -&gt; StateSchema:
    return (
        self.local_state.schema() if self.local_state is not None else StateSchema()
    )</code></pre>
</details>
</dd>
<dt id="algoappdev.apps.AppBuilder.update_txn"><code class="name flex">
<span>def <span class="ident">update_txn</span></span>(<span>self, client: algosdk.v2client.algod.AlgodClient, address: str, params: algosdk.future.transaction.SuggestedParams, app_id: int) ‑> algosdk.future.transaction.ApplicationUpdateTxn</span>
</code></dt>
<dd>
<div class="desc"><p>Build the transaction to update an app with this data.</p>
<p>NOTE: the schema cannot be changed in an update transaction, meaning
the state must be the same as that already used in <code>app_id</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>client</code></strong></dt>
<dd>the client connected to a node with the developer API, used
for compiling and to send the transaction</dd>
<dt><strong><code>address</code></strong></dt>
<dd>the address of the app creator sending the transaction</dd>
<dt><strong><code>params</code></strong></dt>
<dd>the transaction parameters</dd>
<dt><strong><code>app_id</code></strong></dt>
<dd>the id of the exisiting application to update</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_txn(
    self,
    client: AlgodClient,
    address: str,
    params: SuggestedParams,
    app_id: int,
) -&gt; ApplicationUpdateTxn:
    &#34;&#34;&#34;
    Build the transaction to update an app with this data.

    NOTE: the schema cannot be changed in an update transaction, meaning
    the state must be the same as that already used in `app_id`.

    Args:
        client: the client connected to a node with the developer API, used
            for compiling and to send the transaction
        address: the address of the app creator sending the transaction
        params: the transaction parameters
        app_id: the id of the exisiting application to update
    &#34;&#34;&#34;
    # ensure a valid clear program, interpret None as return zero
    return ApplicationUpdateTxn(
        sender=address,
        sp=params,
        index=app_id,
        approval_program=compile_source(client, compile_expr(self.approval_expr())),
        clear_program=compile_source(client, compile_expr(self.clear_exrp())),
    )</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="algoappdev.apps.State"><code class="flex name class">
<span>class <span class="ident">State</span></span>
<span>(</span><span>infos: List[<a title="algoappdev.apps.State.KeyInfo" href="#algoappdev.apps.State.KeyInfo">State.KeyInfo</a>])</span>
</code></dt>
<dd>
<div class="desc"><p>Describes an app's state.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class State:
    &#34;&#34;&#34;Describes an app&#39;s state.&#34;&#34;&#34;

    class KeyInfo:
        &#34;&#34;&#34;
        Information about an app state key and associated value.
        &#34;&#34;&#34;

        def __init__(self, key: Key, type: TealType, default: tl.Expr = None):
            key = self.as_bytes(key)
            # the key as bytes
            self.key = key
            # the tl type of the key&#39;s value
            self.type = type
            # the tl expression to populate the initial value (can be None)
            self.default = default

        @staticmethod
        def as_bytes(key: Key) -&gt; bytes:
            &#34;&#34;&#34;
            Convert a key to it&#39;s byte representation. Validates that the key
            length doesn&#39;t surpass the Algorand maximum of 64 bytes.
            &#34;&#34;&#34;
            if isinstance(key, int):
                # At most 64 keys are allowed, so this fits in a byte. The
                # byte order is arbitrary as this is handled internally, but
                # use big-endian anyway to be consistent with TEAL conventions.
                key = key.to_bytes(1, &#34;big&#34;)
            if isinstance(key, str):
                return key.encode(&#34;utf8&#34;)
            elif isinstance(key, bytes):
                pass
            else:
                raise AlgoAppDevError(f&#34;invalid key type: {type(key)}&#34;)
            if len(key) &gt; 64:
                raise AlgoAppDevError(f&#34;key too long: {key}&#34;)
            return key

    def __init__(self, infos: List[KeyInfo]):
        self._key_to_info = {i.key: i for i in infos}
        self._maybe_values: Dict[bytes, tl.MaybeValue] = {}

    def key_info(self, key: Key):
        return self._key_to_info[State.KeyInfo.as_bytes(key)]

    def key_infos(self) -&gt; List[KeyInfo]:
        return list(self._key_to_info.values())

    def schema(self) -&gt; StateSchema:
        &#34;&#34;&#34;Build the schema for this state.&#34;&#34;&#34;
        num_uints = 0
        num_byte_slices = 0

        for info in self._key_to_info.values():
            if info.type is tl.Int:
                num_uints += 1
            elif info.type is tl.Bytes:
                num_byte_slices += 1

        return StateSchema(num_uints=num_uints, num_byte_slices=num_byte_slices)</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="algoappdev.apps.StateGlobalExternal" href="#algoappdev.apps.StateGlobalExternal">StateGlobalExternal</a></li>
<li><a title="algoappdev.apps.StateLocalExternal" href="#algoappdev.apps.StateLocalExternal">StateLocalExternal</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="algoappdev.apps.State.KeyInfo"><code class="name">var <span class="ident">KeyInfo</span></code></dt>
<dd>
<div class="desc"><p>Information about an app state key and associated value.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="algoappdev.apps.State.key_info"><code class="name flex">
<span>def <span class="ident">key_info</span></span>(<span>self, key: Union[int, str, bytes])</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def key_info(self, key: Key):
    return self._key_to_info[State.KeyInfo.as_bytes(key)]</code></pre>
</details>
</dd>
<dt id="algoappdev.apps.State.key_infos"><code class="name flex">
<span>def <span class="ident">key_infos</span></span>(<span>self) ‑> List[<a title="algoappdev.apps.State.KeyInfo" href="#algoappdev.apps.State.KeyInfo">State.KeyInfo</a>]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def key_infos(self) -&gt; List[KeyInfo]:
    return list(self._key_to_info.values())</code></pre>
</details>
</dd>
<dt id="algoappdev.apps.State.schema"><code class="name flex">
<span>def <span class="ident">schema</span></span>(<span>self) ‑> algosdk.future.transaction.StateSchema</span>
</code></dt>
<dd>
<div class="desc"><p>Build the schema for this state.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def schema(self) -&gt; StateSchema:
    &#34;&#34;&#34;Build the schema for this state.&#34;&#34;&#34;
    num_uints = 0
    num_byte_slices = 0

    for info in self._key_to_info.values():
        if info.type is tl.Int:
            num_uints += 1
        elif info.type is tl.Bytes:
            num_byte_slices += 1

    return StateSchema(num_uints=num_uints, num_byte_slices=num_byte_slices)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="algoappdev.apps.StateGlobal"><code class="flex name class">
<span>class <span class="ident">StateGlobal</span></span>
<span>(</span><span>keys: List[<a title="algoappdev.apps.State.KeyInfo" href="#algoappdev.apps.State.KeyInfo">State.KeyInfo</a>])</span>
</code></dt>
<dd>
<div class="desc"><p>Read global state values which might or might not be present. This is the
only way to interface with external apps, and can also be used to access
values which might not yet be set in the current app.</p>
<p>An object <code>MaybeValue</code> is itself a teal expression. It is also stateful,
in that the expression, once constructed, stores the value into a slot,
and that slot is cached in the <code>MaybeValue</code> object.</p>
<p>For example:</p>
<pre><code>myabe = App.globalGetEx(app_id, key)
Seq(maybe, maybe.value())
</code></pre>
<p>In this snippet, the sequence first stores the values retreived by get,
then the value is loaded onto the stack and can be used. To re-used the
value from the given <code>key</code>, it is necessary to use the <em>same</em> <code>maybe</code>
objet, as this one remembers which slot the value is stored in.</p>
<p>Making a second <code>MaybeValue</code> object whith the same key will not re-use the
stored values from the first object. The second object could also evaluated
to store the same value into a <em>new</em> slot. But without this step, it's
<code>load</code> method is oblivious to the slots used by the <code>globalGetEx</code> call.</p>
<p>See <code>StateGlobalRead</code> but with write capability.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class StateGlobal(StateGlobalExternal):
    def __init__(
        self,
        keys: List[State.KeyInfo],
    ):
        &#34;&#34;&#34;See `StateGlobalRead` but with write capability.&#34;&#34;&#34;
        # only state of the current application can be written
        super().__init__(keys, tl.Global.current_application_id())

    def get(self, key: Key) -&gt; tl.Expr:
        &#34;&#34;&#34;Build the expression to get the state value at `key`&#34;&#34;&#34;
        info = self.key_info(key)
        return tl.App.globalGet(tl.Bytes(info.key))

    def set(self, key: Key, value: TealValue) -&gt; tl.Expr:
        &#34;&#34;&#34;Build the expression to set the state value at `key`&#34;&#34;&#34;
        info = self.key_info(key)
        return tl.App.globalPut(tl.Bytes(info.key), value)

    def constructor(self) -&gt; tl.Expr:
        &#34;&#34;&#34;
        Build the expression to set the initial state values for those keys
        with an `default` member.
        &#34;&#34;&#34;
        return tl.Seq(
            *[
                tl.App.globalPut(tl.Bytes(i.key), i.default)
                for i in self.key_infos()
                if i.default
            ]
        )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="algoappdev.apps.StateGlobalExternal" href="#algoappdev.apps.StateGlobalExternal">StateGlobalExternal</a></li>
<li><a title="algoappdev.apps.State" href="#algoappdev.apps.State">State</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="algoappdev.apps.StateGlobal.constructor"><code class="name flex">
<span>def <span class="ident">constructor</span></span>(<span>self) ‑> pyteal.Expr</span>
</code></dt>
<dd>
<div class="desc"><p>Build the expression to set the initial state values for those keys
with an <code>default</code> member.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def constructor(self) -&gt; tl.Expr:
    &#34;&#34;&#34;
    Build the expression to set the initial state values for those keys
    with an `default` member.
    &#34;&#34;&#34;
    return tl.Seq(
        *[
            tl.App.globalPut(tl.Bytes(i.key), i.default)
            for i in self.key_infos()
            if i.default
        ]
    )</code></pre>
</details>
</dd>
<dt id="algoappdev.apps.StateGlobal.get"><code class="name flex">
<span>def <span class="ident">get</span></span>(<span>self, key: Union[int, str, bytes]) ‑> pyteal.Expr</span>
</code></dt>
<dd>
<div class="desc"><p>Build the expression to get the state value at <code>key</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get(self, key: Key) -&gt; tl.Expr:
    &#34;&#34;&#34;Build the expression to get the state value at `key`&#34;&#34;&#34;
    info = self.key_info(key)
    return tl.App.globalGet(tl.Bytes(info.key))</code></pre>
</details>
</dd>
<dt id="algoappdev.apps.StateGlobal.set"><code class="name flex">
<span>def <span class="ident">set</span></span>(<span>self, key: Union[int, str, bytes], value: Union[pyteal.Int, pyteal.Bytes]) ‑> pyteal.Expr</span>
</code></dt>
<dd>
<div class="desc"><p>Build the expression to set the state value at <code>key</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set(self, key: Key, value: TealValue) -&gt; tl.Expr:
    &#34;&#34;&#34;Build the expression to set the state value at `key`&#34;&#34;&#34;
    info = self.key_info(key)
    return tl.App.globalPut(tl.Bytes(info.key), value)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="algoappdev.apps.StateGlobalExternal" href="#algoappdev.apps.StateGlobalExternal">StateGlobalExternal</a></b></code>:
<ul class="hlist">
<li><code><a title="algoappdev.apps.StateGlobalExternal.KeyInfo" href="#algoappdev.apps.State.KeyInfo">KeyInfo</a></code></li>
<li><code><a title="algoappdev.apps.StateGlobalExternal.get_ex" href="#algoappdev.apps.StateGlobalExternal.get_ex">get_ex</a></code></li>
<li><code><a title="algoappdev.apps.StateGlobalExternal.load_ex_has_value" href="#algoappdev.apps.StateGlobalExternal.load_ex_has_value">load_ex_has_value</a></code></li>
<li><code><a title="algoappdev.apps.StateGlobalExternal.load_ex_value" href="#algoappdev.apps.StateGlobalExternal.load_ex_value">load_ex_value</a></code></li>
<li><code><a title="algoappdev.apps.StateGlobalExternal.schema" href="#algoappdev.apps.State.schema">schema</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="algoappdev.apps.StateGlobalExternal"><code class="flex name class">
<span>class <span class="ident">StateGlobalExternal</span></span>
<span>(</span><span>keys: List[<a title="algoappdev.apps.State.KeyInfo" href="#algoappdev.apps.State.KeyInfo">State.KeyInfo</a>], app_id: pyteal.Expr)</span>
</code></dt>
<dd>
<div class="desc"><p>Read global state values which might or might not be present. This is the
only way to interface with external apps, and can also be used to access
values which might not yet be set in the current app.</p>
<p>An object <code>MaybeValue</code> is itself a teal expression. It is also stateful,
in that the expression, once constructed, stores the value into a slot,
and that slot is cached in the <code>MaybeValue</code> object.</p>
<p>For example:</p>
<pre><code>myabe = App.globalGetEx(app_id, key)
Seq(maybe, maybe.value())
</code></pre>
<p>In this snippet, the sequence first stores the values retreived by get,
then the value is loaded onto the stack and can be used. To re-used the
value from the given <code>key</code>, it is necessary to use the <em>same</em> <code>maybe</code>
objet, as this one remembers which slot the value is stored in.</p>
<p>Making a second <code>MaybeValue</code> object whith the same key will not re-use the
stored values from the first object. The second object could also evaluated
to store the same value into a <em>new</em> slot. But without this step, it's
<code>load</code> method is oblivious to the slots used by the <code>globalGetEx</code> call.</p>
<p>Build the read-only global state representation for app at <code>app_id</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>app_id</code></strong></dt>
<dd>expression evaluating to the id of an app in the app array</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class StateGlobalExternal(State):
    &#34;&#34;&#34;
    Read global state values which might or might not be present. This is the
    only way to interface with external apps, and can also be used to access
    values which might not yet be set in the current app.

    An object `MaybeValue` is itself a teal expression. It is also stateful,
    in that the expression, once constructed, stores the value into a slot,
    and that slot is cached in the `MaybeValue` object.

    For example:

    ```
    myabe = App.globalGetEx(app_id, key)
    Seq(maybe, maybe.value())
    ```

    In this snippet, the sequence first stores the values retreived by get,
    then the value is loaded onto the stack and can be used. To re-used the
    value from the given `key`, it is necessary to use the *same* `maybe`
    objet, as this one remembers which slot the value is stored in.

    Making a second `MaybeValue` object whith the same key will not re-use the
    stored values from the first object. The second object could also evaluated
    to store the same value into a *new* slot. But without this step, it&#39;s
    `load` method is oblivious to the slots used by the `globalGetEx` call.
    &#34;&#34;&#34;

    def __init__(self, keys: List[State.KeyInfo], app_id: tl.Expr):
        &#34;&#34;&#34;
        Build the read-only global state representation for app at `app_id`.

        Args:
            app_id: expression evaluating to the id of an app in the app array
        &#34;&#34;&#34;
        super().__init__(keys)
        self.app_id = app_id

    def get_ex(self, key: Key) -&gt; tl.MaybeValue:
        &#34;&#34;&#34;
        Get the `MaybeValue` object for `key`.

        The object itself is an expression to load the value into a slot. It
        also has members for accessing that value.

        After evaluating `MaybeValue`, then that object can be used to generate
        expression to access the value: `MaybeValue.value`. This means that a
        `MaybeValue` object must be cached if its value is to be accessed more
        than once, so it can remember which slot the value was stored in.
        &#34;&#34;&#34;
        info = self.key_info(key)
        maybe_value = self._maybe_values.get(info.key, None)
        if maybe_value is None:
            maybe_value = tl.App.globalGetEx(self.app_id, tl.Bytes(info.key))
            self._maybe_values[info.key] = maybe_value
        return maybe_value

    def load_ex_value(self, key: Key) -&gt; tl.Expr:
        &#34;&#34;&#34;
        Load a `MaybeValue` into a slot and return its value.

        If the key was previously loaded, the same scratch slot will be used.
        However, this will call `globalGetEx` and store its result anew, albeit
        in the same slot.

        The cost of repeating these operations can be avoided by pre-storing
        the value into a slot at the start of the program, and then accessing
        its `load` member subsequently.

        ```
        maybe = state.get_ex(key)
        expr = Seq(
            maybe,
            # ... some teal logic, with possible branches
            maybe.value()
            # ... some more teal logic
            maybe.value()
        )
        ```
        &#34;&#34;&#34;
        maybe_value = self.get_ex(key)
        return tl.Seq(maybe_value, maybe_value.value())

    def load_ex_has_value(self, key: Key) -&gt; tl.Expr:
        &#34;&#34;&#34;
        Load a `MaybeValue` into a slot and return if it has a value.

        See `load_ex_value` for notes on the `globalGetEx` calls.
        &#34;&#34;&#34;
        maybe_value = self.get_ex(key)
        return tl.Seq(maybe_value, maybe_value.hasValue())</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="algoappdev.apps.State" href="#algoappdev.apps.State">State</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="algoappdev.apps.StateGlobal" href="#algoappdev.apps.StateGlobal">StateGlobal</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="algoappdev.apps.StateGlobalExternal.get_ex"><code class="name flex">
<span>def <span class="ident">get_ex</span></span>(<span>self, key: Union[int, str, bytes]) ‑> pyteal.MaybeValue</span>
</code></dt>
<dd>
<div class="desc"><p>Get the <code>MaybeValue</code> object for <code>key</code>.</p>
<p>The object itself is an expression to load the value into a slot. It
also has members for accessing that value.</p>
<p>After evaluating <code>MaybeValue</code>, then that object can be used to generate
expression to access the value: <code>MaybeValue.value</code>. This means that a
<code>MaybeValue</code> object must be cached if its value is to be accessed more
than once, so it can remember which slot the value was stored in.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_ex(self, key: Key) -&gt; tl.MaybeValue:
    &#34;&#34;&#34;
    Get the `MaybeValue` object for `key`.

    The object itself is an expression to load the value into a slot. It
    also has members for accessing that value.

    After evaluating `MaybeValue`, then that object can be used to generate
    expression to access the value: `MaybeValue.value`. This means that a
    `MaybeValue` object must be cached if its value is to be accessed more
    than once, so it can remember which slot the value was stored in.
    &#34;&#34;&#34;
    info = self.key_info(key)
    maybe_value = self._maybe_values.get(info.key, None)
    if maybe_value is None:
        maybe_value = tl.App.globalGetEx(self.app_id, tl.Bytes(info.key))
        self._maybe_values[info.key] = maybe_value
    return maybe_value</code></pre>
</details>
</dd>
<dt id="algoappdev.apps.StateGlobalExternal.load_ex_has_value"><code class="name flex">
<span>def <span class="ident">load_ex_has_value</span></span>(<span>self, key: Union[int, str, bytes]) ‑> pyteal.Expr</span>
</code></dt>
<dd>
<div class="desc"><p>Load a <code>MaybeValue</code> into a slot and return if it has a value.</p>
<p>See <code>load_ex_value</code> for notes on the <code>globalGetEx</code> calls.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_ex_has_value(self, key: Key) -&gt; tl.Expr:
    &#34;&#34;&#34;
    Load a `MaybeValue` into a slot and return if it has a value.

    See `load_ex_value` for notes on the `globalGetEx` calls.
    &#34;&#34;&#34;
    maybe_value = self.get_ex(key)
    return tl.Seq(maybe_value, maybe_value.hasValue())</code></pre>
</details>
</dd>
<dt id="algoappdev.apps.StateGlobalExternal.load_ex_value"><code class="name flex">
<span>def <span class="ident">load_ex_value</span></span>(<span>self, key: Union[int, str, bytes]) ‑> pyteal.Expr</span>
</code></dt>
<dd>
<div class="desc"><p>Load a <code>MaybeValue</code> into a slot and return its value.</p>
<p>If the key was previously loaded, the same scratch slot will be used.
However, this will call <code>globalGetEx</code> and store its result anew, albeit
in the same slot.</p>
<p>The cost of repeating these operations can be avoided by pre-storing
the value into a slot at the start of the program, and then accessing
its <code>load</code> member subsequently.</p>
<pre><code>maybe = state.get_ex(key)
expr = Seq(
    maybe,
    # ... some teal logic, with possible branches
    maybe.value()
    # ... some more teal logic
    maybe.value()
)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_ex_value(self, key: Key) -&gt; tl.Expr:
    &#34;&#34;&#34;
    Load a `MaybeValue` into a slot and return its value.

    If the key was previously loaded, the same scratch slot will be used.
    However, this will call `globalGetEx` and store its result anew, albeit
    in the same slot.

    The cost of repeating these operations can be avoided by pre-storing
    the value into a slot at the start of the program, and then accessing
    its `load` member subsequently.

    ```
    maybe = state.get_ex(key)
    expr = Seq(
        maybe,
        # ... some teal logic, with possible branches
        maybe.value()
        # ... some more teal logic
        maybe.value()
    )
    ```
    &#34;&#34;&#34;
    maybe_value = self.get_ex(key)
    return tl.Seq(maybe_value, maybe_value.value())</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="algoappdev.apps.State" href="#algoappdev.apps.State">State</a></b></code>:
<ul class="hlist">
<li><code><a title="algoappdev.apps.State.KeyInfo" href="#algoappdev.apps.State.KeyInfo">KeyInfo</a></code></li>
<li><code><a title="algoappdev.apps.State.schema" href="#algoappdev.apps.State.schema">schema</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="algoappdev.apps.StateLocal"><code class="flex name class">
<span>class <span class="ident">StateLocal</span></span>
<span>(</span><span>keys: List[<a title="algoappdev.apps.State.KeyInfo" href="#algoappdev.apps.State.KeyInfo">State.KeyInfo</a>])</span>
</code></dt>
<dd>
<div class="desc"><p>See <code><a title="algoappdev.apps.StateGlobalExternal" href="#algoappdev.apps.StateGlobalExternal">StateGlobalExternal</a></code>, but for the local state.</p>
<p>Build the local state representation for app at <code>app_id</code> in <code>account</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>app_id</code></strong></dt>
<dd>expression evaluating to the id of an app in the app array</dd>
<dt><strong><code>account</code></strong></dt>
<dd>expression evaluating to the account whose state is to be
accessed</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class StateLocal(StateLocalExternal):
    def __init__(
        self,
        keys: List[State.KeyInfo],
    ):
        &#34;&#34;&#34;
        Build the local state representation for app at `app_id` in `account`.

        Args:
            app_id: expression evaluating to the id of an app in the app array
            account: expression evaluating to the account whose state is to be
                accessed
        &#34;&#34;&#34;
        # only state of the current application for the sender can be written
        super().__init__(keys, tl.Global.current_application_id(), tl.Txn.sender())

    def get(self, key: Key) -&gt; tl.Expr:
        &#34;&#34;&#34;Build the expression to get the state value at `key`&#34;&#34;&#34;
        info = self.key_info(key)
        return tl.App.localGet(self.account, tl.Bytes(info.key))

    def set(self, key: Key, value: TealValue) -&gt; tl.Expr:
        &#34;&#34;&#34;Build the expression to set the state value at `key`&#34;&#34;&#34;
        info = self.key_info(key)
        return tl.App.localPut(self.account, tl.Bytes(info.key), value)

    def constructor(self) -&gt; tl.Expr:
        &#34;&#34;&#34;
        Build the expression to set the initial state values for those keys
        with an `default` member.
        &#34;&#34;&#34;
        return tl.Seq(
            *[
                tl.App.localPut(self.account, tl.Bytes(i.key), i.default)
                for i in self.key_infos()
                if i.default
            ]
        )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="algoappdev.apps.StateLocalExternal" href="#algoappdev.apps.StateLocalExternal">StateLocalExternal</a></li>
<li><a title="algoappdev.apps.State" href="#algoappdev.apps.State">State</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="algoappdev.apps.StateLocal.constructor"><code class="name flex">
<span>def <span class="ident">constructor</span></span>(<span>self) ‑> pyteal.Expr</span>
</code></dt>
<dd>
<div class="desc"><p>Build the expression to set the initial state values for those keys
with an <code>default</code> member.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def constructor(self) -&gt; tl.Expr:
    &#34;&#34;&#34;
    Build the expression to set the initial state values for those keys
    with an `default` member.
    &#34;&#34;&#34;
    return tl.Seq(
        *[
            tl.App.localPut(self.account, tl.Bytes(i.key), i.default)
            for i in self.key_infos()
            if i.default
        ]
    )</code></pre>
</details>
</dd>
<dt id="algoappdev.apps.StateLocal.get"><code class="name flex">
<span>def <span class="ident">get</span></span>(<span>self, key: Union[int, str, bytes]) ‑> pyteal.Expr</span>
</code></dt>
<dd>
<div class="desc"><p>Build the expression to get the state value at <code>key</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get(self, key: Key) -&gt; tl.Expr:
    &#34;&#34;&#34;Build the expression to get the state value at `key`&#34;&#34;&#34;
    info = self.key_info(key)
    return tl.App.localGet(self.account, tl.Bytes(info.key))</code></pre>
</details>
</dd>
<dt id="algoappdev.apps.StateLocal.set"><code class="name flex">
<span>def <span class="ident">set</span></span>(<span>self, key: Union[int, str, bytes], value: Union[pyteal.Int, pyteal.Bytes]) ‑> pyteal.Expr</span>
</code></dt>
<dd>
<div class="desc"><p>Build the expression to set the state value at <code>key</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set(self, key: Key, value: TealValue) -&gt; tl.Expr:
    &#34;&#34;&#34;Build the expression to set the state value at `key`&#34;&#34;&#34;
    info = self.key_info(key)
    return tl.App.localPut(self.account, tl.Bytes(info.key), value)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="algoappdev.apps.StateLocalExternal" href="#algoappdev.apps.StateLocalExternal">StateLocalExternal</a></b></code>:
<ul class="hlist">
<li><code><a title="algoappdev.apps.StateLocalExternal.KeyInfo" href="#algoappdev.apps.State.KeyInfo">KeyInfo</a></code></li>
<li><code><a title="algoappdev.apps.StateLocalExternal.get_ex" href="#algoappdev.apps.StateLocalExternal.get_ex">get_ex</a></code></li>
<li><code><a title="algoappdev.apps.StateLocalExternal.load_ex_has_value" href="#algoappdev.apps.StateLocalExternal.load_ex_has_value">load_ex_has_value</a></code></li>
<li><code><a title="algoappdev.apps.StateLocalExternal.load_ex_value" href="#algoappdev.apps.StateLocalExternal.load_ex_value">load_ex_value</a></code></li>
<li><code><a title="algoappdev.apps.StateLocalExternal.schema" href="#algoappdev.apps.State.schema">schema</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="algoappdev.apps.StateLocalExternal"><code class="flex name class">
<span>class <span class="ident">StateLocalExternal</span></span>
<span>(</span><span>keys: List[<a title="algoappdev.apps.State.KeyInfo" href="#algoappdev.apps.State.KeyInfo">State.KeyInfo</a>], app_id: pyteal.Expr, account: pyteal.Expr)</span>
</code></dt>
<dd>
<div class="desc"><p>See <code><a title="algoappdev.apps.StateGlobalExternal" href="#algoappdev.apps.StateGlobalExternal">StateGlobalExternal</a></code>, but for the local state.</p>
<p>Build the read-only local state representation for app at <code>app_id</code> in
<code>account</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>app_id</code></strong></dt>
<dd>expression evaluating to the id of an app in the app array</dd>
<dt><strong><code>account</code></strong></dt>
<dd>expression evaluating to the account whose state is to be
accessed</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class StateLocalExternal(State):
    &#34;&#34;&#34;See `StateGlobalExternal`, but for the local state.&#34;&#34;&#34;

    def __init__(self, keys: List[State.KeyInfo], app_id: tl.Expr, account: tl.Expr):
        &#34;&#34;&#34;
        Build the read-only local state representation for app at `app_id` in
        `account`.

        Args:
            app_id: expression evaluating to the id of an app in the app array
            account: expression evaluating to the account whose state is to be
                accessed
        &#34;&#34;&#34;
        super().__init__(keys)
        self.app_id = app_id
        self.account = account

    def get_ex(self, key: Key) -&gt; tl.MaybeValue:
        &#34;&#34;&#34;
        Get the `MaybeValue` object for `key`.

        See `StateGlobalExternal.get_ex`.
        &#34;&#34;&#34;
        info = self.key_info(key)
        maybe_value = self._maybe_values.get(info.key, None)
        if maybe_value is None:
            maybe_value = tl.App.localGetEx(
                self.account, self.app_id, tl.Bytes(info.key)
            )
            self._maybe_values[info.key] = maybe_value
        return maybe_value

    def load_ex_value(self, key: Key) -&gt; tl.Expr:
        &#34;&#34;&#34;
        Load a `MaybeValue` into a slot and return its value.

        See `StateGlobalExternal.load_ex_value`.
        &#34;&#34;&#34;
        maybe_value = self.get_ex(key)
        return tl.Seq(maybe_value, maybe_value.value())

    def load_ex_has_value(self, key: Key) -&gt; tl.Expr:
        &#34;&#34;&#34;
        Load a `MaybeValue` into a slot and return if it has a value.

        See `StateGlobalExternal.load_ex_has_value`.
        &#34;&#34;&#34;
        maybe_value = self.get_ex(key)
        return tl.Seq(maybe_value, maybe_value.hasValue())</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="algoappdev.apps.State" href="#algoappdev.apps.State">State</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="algoappdev.apps.StateLocal" href="#algoappdev.apps.StateLocal">StateLocal</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="algoappdev.apps.StateLocalExternal.get_ex"><code class="name flex">
<span>def <span class="ident">get_ex</span></span>(<span>self, key: Union[int, str, bytes]) ‑> pyteal.MaybeValue</span>
</code></dt>
<dd>
<div class="desc"><p>Get the <code>MaybeValue</code> object for <code>key</code>.</p>
<p>See <code><a title="algoappdev.apps.StateGlobalExternal.get_ex" href="#algoappdev.apps.StateGlobalExternal.get_ex">StateGlobalExternal.get_ex()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_ex(self, key: Key) -&gt; tl.MaybeValue:
    &#34;&#34;&#34;
    Get the `MaybeValue` object for `key`.

    See `StateGlobalExternal.get_ex`.
    &#34;&#34;&#34;
    info = self.key_info(key)
    maybe_value = self._maybe_values.get(info.key, None)
    if maybe_value is None:
        maybe_value = tl.App.localGetEx(
            self.account, self.app_id, tl.Bytes(info.key)
        )
        self._maybe_values[info.key] = maybe_value
    return maybe_value</code></pre>
</details>
</dd>
<dt id="algoappdev.apps.StateLocalExternal.load_ex_has_value"><code class="name flex">
<span>def <span class="ident">load_ex_has_value</span></span>(<span>self, key: Union[int, str, bytes]) ‑> pyteal.Expr</span>
</code></dt>
<dd>
<div class="desc"><p>Load a <code>MaybeValue</code> into a slot and return if it has a value.</p>
<p>See <code><a title="algoappdev.apps.StateGlobalExternal.load_ex_has_value" href="#algoappdev.apps.StateGlobalExternal.load_ex_has_value">StateGlobalExternal.load_ex_has_value()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_ex_has_value(self, key: Key) -&gt; tl.Expr:
    &#34;&#34;&#34;
    Load a `MaybeValue` into a slot and return if it has a value.

    See `StateGlobalExternal.load_ex_has_value`.
    &#34;&#34;&#34;
    maybe_value = self.get_ex(key)
    return tl.Seq(maybe_value, maybe_value.hasValue())</code></pre>
</details>
</dd>
<dt id="algoappdev.apps.StateLocalExternal.load_ex_value"><code class="name flex">
<span>def <span class="ident">load_ex_value</span></span>(<span>self, key: Union[int, str, bytes]) ‑> pyteal.Expr</span>
</code></dt>
<dd>
<div class="desc"><p>Load a <code>MaybeValue</code> into a slot and return its value.</p>
<p>See <code><a title="algoappdev.apps.StateGlobalExternal.load_ex_value" href="#algoappdev.apps.StateGlobalExternal.load_ex_value">StateGlobalExternal.load_ex_value()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_ex_value(self, key: Key) -&gt; tl.Expr:
    &#34;&#34;&#34;
    Load a `MaybeValue` into a slot and return its value.

    See `StateGlobalExternal.load_ex_value`.
    &#34;&#34;&#34;
    maybe_value = self.get_ex(key)
    return tl.Seq(maybe_value, maybe_value.value())</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="algoappdev.apps.State" href="#algoappdev.apps.State">State</a></b></code>:
<ul class="hlist">
<li><code><a title="algoappdev.apps.State.KeyInfo" href="#algoappdev.apps.State.KeyInfo">KeyInfo</a></code></li>
<li><code><a title="algoappdev.apps.State.schema" href="#algoappdev.apps.State.schema">schema</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="algoappdev" href="index.html">algoappdev</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="algoappdev.apps.compile_expr" href="#algoappdev.apps.compile_expr">compile_expr</a></code></li>
<li><code><a title="algoappdev.apps.compile_source" href="#algoappdev.apps.compile_source">compile_source</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="algoappdev.apps.AppBuilder" href="#algoappdev.apps.AppBuilder">AppBuilder</a></code></h4>
<ul class="two-column">
<li><code><a title="algoappdev.apps.AppBuilder.approval_expr" href="#algoappdev.apps.AppBuilder.approval_expr">approval_expr</a></code></li>
<li><code><a title="algoappdev.apps.AppBuilder.clear_exrp" href="#algoappdev.apps.AppBuilder.clear_exrp">clear_exrp</a></code></li>
<li><code><a title="algoappdev.apps.AppBuilder.create_txn" href="#algoappdev.apps.AppBuilder.create_txn">create_txn</a></code></li>
<li><code><a title="algoappdev.apps.AppBuilder.global_schema" href="#algoappdev.apps.AppBuilder.global_schema">global_schema</a></code></li>
<li><code><a title="algoappdev.apps.AppBuilder.global_state" href="#algoappdev.apps.AppBuilder.global_state">global_state</a></code></li>
<li><code><a title="algoappdev.apps.AppBuilder.invocations" href="#algoappdev.apps.AppBuilder.invocations">invocations</a></code></li>
<li><code><a title="algoappdev.apps.AppBuilder.local_schema" href="#algoappdev.apps.AppBuilder.local_schema">local_schema</a></code></li>
<li><code><a title="algoappdev.apps.AppBuilder.local_state" href="#algoappdev.apps.AppBuilder.local_state">local_state</a></code></li>
<li><code><a title="algoappdev.apps.AppBuilder.on_clear" href="#algoappdev.apps.AppBuilder.on_clear">on_clear</a></code></li>
<li><code><a title="algoappdev.apps.AppBuilder.on_close_out" href="#algoappdev.apps.AppBuilder.on_close_out">on_close_out</a></code></li>
<li><code><a title="algoappdev.apps.AppBuilder.on_create" href="#algoappdev.apps.AppBuilder.on_create">on_create</a></code></li>
<li><code><a title="algoappdev.apps.AppBuilder.on_delete" href="#algoappdev.apps.AppBuilder.on_delete">on_delete</a></code></li>
<li><code><a title="algoappdev.apps.AppBuilder.on_no_op" href="#algoappdev.apps.AppBuilder.on_no_op">on_no_op</a></code></li>
<li><code><a title="algoappdev.apps.AppBuilder.on_opt_in" href="#algoappdev.apps.AppBuilder.on_opt_in">on_opt_in</a></code></li>
<li><code><a title="algoappdev.apps.AppBuilder.on_update" href="#algoappdev.apps.AppBuilder.on_update">on_update</a></code></li>
<li><code><a title="algoappdev.apps.AppBuilder.update_txn" href="#algoappdev.apps.AppBuilder.update_txn">update_txn</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="algoappdev.apps.State" href="#algoappdev.apps.State">State</a></code></h4>
<ul class="">
<li><code><a title="algoappdev.apps.State.KeyInfo" href="#algoappdev.apps.State.KeyInfo">KeyInfo</a></code></li>
<li><code><a title="algoappdev.apps.State.key_info" href="#algoappdev.apps.State.key_info">key_info</a></code></li>
<li><code><a title="algoappdev.apps.State.key_infos" href="#algoappdev.apps.State.key_infos">key_infos</a></code></li>
<li><code><a title="algoappdev.apps.State.schema" href="#algoappdev.apps.State.schema">schema</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="algoappdev.apps.StateGlobal" href="#algoappdev.apps.StateGlobal">StateGlobal</a></code></h4>
<ul class="">
<li><code><a title="algoappdev.apps.StateGlobal.constructor" href="#algoappdev.apps.StateGlobal.constructor">constructor</a></code></li>
<li><code><a title="algoappdev.apps.StateGlobal.get" href="#algoappdev.apps.StateGlobal.get">get</a></code></li>
<li><code><a title="algoappdev.apps.StateGlobal.set" href="#algoappdev.apps.StateGlobal.set">set</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="algoappdev.apps.StateGlobalExternal" href="#algoappdev.apps.StateGlobalExternal">StateGlobalExternal</a></code></h4>
<ul class="">
<li><code><a title="algoappdev.apps.StateGlobalExternal.get_ex" href="#algoappdev.apps.StateGlobalExternal.get_ex">get_ex</a></code></li>
<li><code><a title="algoappdev.apps.StateGlobalExternal.load_ex_has_value" href="#algoappdev.apps.StateGlobalExternal.load_ex_has_value">load_ex_has_value</a></code></li>
<li><code><a title="algoappdev.apps.StateGlobalExternal.load_ex_value" href="#algoappdev.apps.StateGlobalExternal.load_ex_value">load_ex_value</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="algoappdev.apps.StateLocal" href="#algoappdev.apps.StateLocal">StateLocal</a></code></h4>
<ul class="">
<li><code><a title="algoappdev.apps.StateLocal.constructor" href="#algoappdev.apps.StateLocal.constructor">constructor</a></code></li>
<li><code><a title="algoappdev.apps.StateLocal.get" href="#algoappdev.apps.StateLocal.get">get</a></code></li>
<li><code><a title="algoappdev.apps.StateLocal.set" href="#algoappdev.apps.StateLocal.set">set</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="algoappdev.apps.StateLocalExternal" href="#algoappdev.apps.StateLocalExternal">StateLocalExternal</a></code></h4>
<ul class="">
<li><code><a title="algoappdev.apps.StateLocalExternal.get_ex" href="#algoappdev.apps.StateLocalExternal.get_ex">get_ex</a></code></li>
<li><code><a title="algoappdev.apps.StateLocalExternal.load_ex_has_value" href="#algoappdev.apps.StateLocalExternal.load_ex_has_value">load_ex_has_value</a></code></li>
<li><code><a title="algoappdev.apps.StateLocalExternal.load_ex_value" href="#algoappdev.apps.StateLocalExternal.load_ex_value">load_ex_value</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>